Report:

My code mostly works from minimum through to core, they have been implemented and worked on but some parts may not be working 100%.
Occasional bugs occur but nothing major. Upon implementing oneWays, it seems sometimes it doesn't find the right (shortest) path.
My way of calculating the distance from A to B is I would use the edge length travelled from A + the straight line distance to B.
This is not the best heuristics function which is why sometimes it may not find the shortest path.




A* Search Algorithm Pseudocode:

Create a fringe that is a PriorityQueue<AStarNode> (comparing the 'f');
Create a list of visited nodes;
add default AStarNode;
while (fringe is not empty){
	aStarNode  = fringe.poll();
	currentNode = get the current node from the aStarNode;
	previousNode = get the previous node from the aStarNode;
	if (currentNode is not visited){
		set it to visited;
		add it to visited nodes;
		set the currentNode's previous field to previousNode;
		if (currentNode == destination node){
			break;
		}

		for (Segments = currentNode.segments){
			find the start and end nodes of the segment;
			if (end node is not visited){
				calculate new g value;
				calculate new f value;
				add it to the fringe;
			}
		}
	}
}

Create a new collection of segments;
for(currentNode in aStarNode; if it's previous != null; set it to its previous){
	for(Segement in currentNode.segments){
		add each segment into the collection and keep traversing through the 'previous' field of the nodes;
	}
}

Set all the visited nodes to unvisited;
Return the collection of segments;


Articulation Points Pseudocode:
Run through all the nodes on the graph and...
if (node is unvisited){
	create a new stack;
	push the initial (neighbour, 1, currentNode);
	
	while(stack is not empty){
	peek the first element <n, count, parent>;
	if(n is unvisited){
		set its count and reachback to its current depth down (parent's count + 1);
		add the neighbours to children (leave out parent);
	}
	
else if(n has childrens){
	go through the children{
		if the child is visited then set reachback(n) to min(count(child), reachback(n));
		else push to stack <child, count+1, n>;
		remove the child that we just worked on;
	}
else {
	if(n does not equal firstNode){
		reachback(parent) = min(reachback(n), reachback(parent);
		if(reachBack(n) >= count(parent)){
			add it to our list or artPoints;
		}
	}
	stack.pop();
}
		